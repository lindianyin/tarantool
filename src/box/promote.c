/*
 * Copyright 2010-2018, Tarantool AUTHORS, please see AUTHORS file.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * 1. Redistributions of source code must retain the above
 *    copyright notice, this list of conditions and the
 *    following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY <COPYRIGHT HOLDER> ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * <COPYRIGHT HOLDER> OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "box.h"
#include "replication.h"
#include "promote.h"
#include "error.h"
#include "msgpuck.h"
#include "xrow.h"
#include "space.h"
#include "schema.h"
#include "schema_def.h"
#include "txn.h"
#include "tuple.h"
#include "iproto_constants.h"
#include "opt_def.h"
#include "info.h"
#include "fiber_channel.h"
#include "evio.h"

enum promote_msg_type {
	PROMOTE_MSG_BEGIN = 0,
	PROMOTE_MSG_STATUS,
	PROMOTE_MSG_SYNC,
	PROMOTE_MSG_SUCCESS,
	PROMOTE_MSG_ERROR,
	promote_msg_type_MAX,
};

static const char *promote_msg_type_strs[] = {
	"begin",
	"status",
	"sync",
	"success",
	"error",
};

/**
 * Promotion message. The unit of communication between an
 * initiator, an old master and watchers.
 */
struct promote_msg {
	/** Interface for fiber channel. */
	struct ipc_msg base;
	/**
	 * Round ID. Together with round UUID composes an unique
	 * round identifier. For details see promotion_state.
	 */
	int round_id;
	/** Promotion round UUID, generated by the initiator. */
	struct tt_uuid round_uuid;
	/** UUID of the message sender. */
	struct tt_uuid source_uuid;
	/**
	 * Timestamp of the message send time by the sender clock.
	 * Just debug attribute, that is persisted.
	 */
	double ts;
	/** Promotion message type. */
	enum promote_msg_type type;
	/** Step of the round on which the message was sent. */
	int step;
	/**
	 * Depending on the message type, different attributes
	 * are available in the message.
	 */
	union {
		struct {
			/**
			 * 'Begin' promotion message carries
			 * quorum and timeout of the new round
			 * among other common things above.
			 */
			int quorum;
			double timeout;
		} begin;
		struct {
			/**
			 * 'Status' message carries the sender
			 * role.
			 */
			bool is_master;
		} status;
		struct {
			/**
			 * 'Error' message carries the error code
			 * and message to be set in diag.
			 */
			int code;
			const char *message;
		} error;
	};
};

enum promote_role {
	PROMOTE_ROLE_UNDEFINED = 0,
	PROMOTE_ROLE_INITIATOR,
	PROMOTE_ROLE_MASTER,
	PROMOTE_ROLE_WATCHER
};

static const char *promote_role_strs[] = {
	"undefined",
	"initiator",
	"old master",
	"watcher",
};

enum promote_phase {
	PROMOTE_PHASE_INACTIVE = 0,
	PROMOTE_PHASE_ERROR,
	PROMOTE_PHASE_SUCCESS,
	PROMOTE_PHASE_IN_PROGRESS,
};

static const char *promote_phase_strs[] = {
	"non-active",
	"error",
	"success",
	"in progress",
};

/**
 * A prototype of a function processing a message under a concrete
 * role with a concrete type.
 */
typedef void (*promote_msg_process_f)(const struct promote_msg *);

/**
 * Promotion state virtual table. It is defined for each promotion
 * role where the later reacts specifically on each message.
 */
struct promote_state_vtab {
	/** Process a 'begin' message. */
	promote_msg_process_f begin;
	/** Process a 'status' message from a replica. */
	promote_msg_process_f new_replica;
	/** Process a 'status' message from a master. */
	promote_msg_process_f new_master;
	/** Process a 'sync' message. */
	promote_msg_process_f sync;
	/** Process a 'success' message. */
	promote_msg_process_f success;
	/** Process an 'error' message. */
	promote_msg_process_f error;
};

/**
 * The current promotion state. If the promotion is finished, then
 * the latest one is stored here as a cache for
 * box.ctl.promote_info().
 */
static struct promote_state {
	/**
	 * Each round has an unique identifier of two parts: ID
	 * and UUID. ID is used to order rounds by the time of
	 * their start. Each new round has an ID > than all the
	 * known previous ones. Timestamps can not be used since
	 * clocks are not perfectly sinced over network.
	 */
	int round_id;
	/**
	 * UUID is generated by a promotion initiator and allows
	 * to protect from an error when promotions are started on
	 * different nodes at the same time with the same round
	 * IDs. UUIDs are different in them because of different
	 * initiators.
	 */
	struct tt_uuid round_uuid;
	/** UUID of a master if known, nil UUID otherwise. */
	struct tt_uuid master_uuid;
	/** UUID of an initiator if known, nil UUID otherwise. */
	struct tt_uuid initiator_uuid;
	/** Diagnostics storing the current round error. */
	struct diag diag;
	/**
	 * Condition emited each time the promotion state is
	 * changed.
	 */
	struct fiber_cond on_change;
	/**
	 * Role of the current instance in the current promotion
	 * round.
	 */
	enum promote_role role;
	/**
	 * Current round promotion phase. If the round is
	 * finsihed, the result (error/success) is stored here as
	 * well.
	 */
	enum promote_phase phase;
	/**
	 * Description of the latest thing done during the current
	 * promotion round. It is not persisted anywhere and
	 * exists merely to improve user experience. It is shown
	 * in box.ctl.promote_info().
	 */
	char comment[DIAG_ERRMSG_MAX + 1];
	/**
	 * The current promotion round quorum. Becomes valid only
	 * when an initiator becomes known. Quorum is number of
	 * replicas that should approve the promotion and sync
	 * with the old master before its demotion. The quorum
	 * includes the old master and the initiator.
	 */
	int quorum;
	/**
	 * Number of already collected syncs with the old master.
	 * Valid on the old master and on the initiator if it acts
	 * on behalf of the later.
	 */
	int sync_count;
	/**
	 * The current promotion round timeout. Once it is
	 * exceeded, the round is terminated with persisting that
	 * fact. Becomes valid only when an initiator becomes
	 * known.
	 */
	double timeout;
	/** Round start time and delay. */
	ev_tstamp round_start;
	ev_tstamp round_delay;
	/** The promotion round worker fiber. */
	struct fiber *worker;
	/** Channel to push messages into worker fiber. */
	struct fiber_channel *channel;
	/**
	 * Number of watchers participating in the current
	 * promotion round. If this value + the initiator equals
	 * the cluster size, then the cluster is read-only. In
	 * such a case the promotion is allowed even though an old
	 * master does not exist. The initiator acts on behalf of
	 * the later then.
	 */
	int watcher_count;
	/**
	 * The current promotion step. It is constantly growing
	 * number for each promotion participant and is used to
	 * persist order of sent messages. Each instance arranges
	 * its messages with step numbers. Also steps are used to
	 * persist relative order of messages from different
	 * sources.
	 */
	int step;
	/** Virtual promotion methods depending on a role. */
	struct promote_state_vtab *vtab;
	/**
	 * True if this instance at least once succeeded to commit
	 * its status and set role. Status message contains
	 * is_master flag that actually is persisted read_only cfg
	 * option. So other instances now are aware of this status
	 * and it can not be changed by a user via box.cfg.
	 */
	bool is_role_committed;
} promote_state;

/**
 * Getters for different attributes and properties of the
 * promotion state.
 */

static inline bool
promote_is_active(void)
{
	return promote_state.phase == PROMOTE_PHASE_IN_PROGRESS;
}

static inline bool
promote_is_master_known(void)
{
	return !tt_uuid_is_equal(&promote_state.master_uuid, &uuid_nil);
}

static inline bool
promote_is_initiator_known(void)
{
	return !tt_uuid_is_equal(&promote_state.initiator_uuid, &uuid_nil);
}

static inline bool
promote_is_cluster_readonly(void)
{
	return promote_state.watcher_count + 1 == replicaset.applier.total;
}

static inline bool
promote_is_this_round_msg(const struct promote_msg *msg)
{
	return promote_is_active() &&
	       tt_uuid_is_equal(&msg->round_uuid, &promote_state.round_uuid);
}

/**
 * Comment a promotion event. The comment text is available to be
 * seen from box.ctl.promote_info(), and is logged.
 */
#define promote_comment(...) do { \
	snprintf(promote_state.comment, sizeof(promote_state.comment), \
		 __VA_ARGS__); \
	say_info(promote_state.comment); \
} while(0)

/**
 * Serialize the promotion message into a string.
 * @param msg Message to serialize.
 * @retval String with the serialized message.
 */
static inline const char *
promote_msg_str(const struct promote_msg *msg)
{
	int offset = 0;
	char *buf = tt_static_buf();
	int len = TT_STATIC_BUF_LEN;

	offset += snprintf(buf, len, "{id: %d, round: '", msg->round_id);
	tt_uuid_to_string(&msg->round_uuid, buf + offset);
	offset += UUID_STR_LEN;
	offset += snprintf(buf + offset, len - offset, "', step: %d, source: '",
			   msg->step);
	tt_uuid_to_string(&msg->source_uuid, buf + offset);
	offset += UUID_STR_LEN;
	offset += snprintf(buf + offset, len - offset, "', ts: %f, type: '%s'",
			   msg->ts, promote_msg_type_strs[msg->type]);
	switch (msg->type) {
	case PROMOTE_MSG_BEGIN:
		offset += snprintf(buf + offset, len - offset, ", quorum: %d, "\
				   "timeout: %f}", msg->begin.quorum,
				   msg->begin.timeout);
		break;
	case PROMOTE_MSG_STATUS:
		offset += snprintf(buf + offset, len - offset, ", is_master: "\
				   "%d}", (int) msg->status.is_master);
		break;
	case PROMOTE_MSG_ERROR:
		offset += snprintf(buf + offset, len - offset, ", code: %d, "\
				   "message: '%s'}", msg->error.code,
				   msg->error.message);
		break;
	default:
		offset += snprintf(buf + offset, len - offset, "}");
		break;
	}
	return buf;
}

/**
 * Encode the promotion message into MessagePack tuple ready to
 * be inserted into _promotion space.
 * @param msg Promotion message to encode.
 *
 * @retval NULL Error.
 * @retval not NULL MessagePack encoded message.
 */
static const char *
promote_msg_encode(const struct promote_msg *msg)
{
	int size = 1024;
	char *data = region_alloc(&fiber()->gc, size);
	if (data == NULL) {
		diag_set(OutOfMemory, size, "region_alloc", "data");
		return NULL;
	}
	char *begin = data;
	data = mp_encode_array(data, 7);
	data = mp_encode_uint(data, msg->round_id);
	data = mp_encode_str(data, tt_uuid_str(&msg->round_uuid),
			     UUID_STR_LEN);
	data = mp_encode_uint(data, msg->step);
	data = mp_encode_str(data, tt_uuid_str(&msg->source_uuid),
			     UUID_STR_LEN);
	data = mp_encode_double(data, msg->ts);
	const char *type_str = promote_msg_type_strs[msg->type];
	data = mp_encode_str(data, type_str, strlen(type_str));
	switch(msg->type) {
	case PROMOTE_MSG_BEGIN:
		data = mp_encode_map(data, 2);
		data = mp_encode_str(data, "quorum", strlen("quorum"));
		data = mp_encode_uint(data, msg->begin.quorum);
		data = mp_encode_str(data, "timeout", strlen("timeout"));
		data = mp_encode_double(data, msg->begin.timeout);
		break;
	case PROMOTE_MSG_STATUS:
		data = mp_encode_map(data, 1);
		data = mp_encode_str(data, "is_master", strlen("is_master"));
		data = mp_encode_bool(data, msg->status.is_master);
		break;
	case PROMOTE_MSG_ERROR:
		data = mp_encode_map(data, 2);
		data = mp_encode_str(data, "code", strlen("code"));
		data = mp_encode_uint(data, msg->error.code);
		data = mp_encode_str(data, "message", strlen("message"));
		data = mp_encode_str(data, msg->error.message,
				     strlen(msg->error.message));
		break;
	default:
		data = mp_encode_nil(data);
		break;
	};
	assert(data - begin <= size);
	return begin;
}

const struct opt_def promote_msg_begin_format[] = {
	OPT_DEF("quorum", OPT_UINT32, struct promote_msg, begin.quorum),
	OPT_DEF("timeout", OPT_FLOAT, struct promote_msg, begin.timeout),
	OPT_END,
};

const struct opt_def promote_msg_status_format[] = {
	OPT_DEF("is_master", OPT_BOOL, struct promote_msg, status.is_master),
	OPT_END,
};

const struct opt_def promote_msg_error_format[] = {
	OPT_DEF("code", OPT_UINT32, struct promote_msg, error.code),
	OPT_DEF("message", OPT_STRPTR, struct promote_msg, error.message),
	OPT_END,
};

void
promote_msg_delete(struct promote_msg *msg)
{
	free(msg);
}

struct promote_msg *
promote_msg_new_from_tuple(const char *data)
{
	uint32_t msg_sizeof = sizeof(struct promote_msg);
	uint32_t size = mp_decode_array(&data);
	assert(size == 7 || size == 6);
	uint32_t len;
	struct region *region = &fiber()->gc;
	struct promote_msg base;
	base.round_id = (int) mp_decode_uint(&data);
	const char *str = mp_decode_str(&data, &len);
	if (tt_uuid_from_strl(str, len, &base.round_uuid) != 0) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_ROUND_UUID, "invalid UUID");
		return NULL;
	}
	base.step = (int) mp_decode_uint(&data);
	str = mp_decode_str(&data, &len);
	if (tt_uuid_from_strl(str, len, &base.source_uuid) != 0) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_SOURCE_UUID, "invalid UUID");
		return NULL;
	}
	if (mp_read_double(&data, &base.ts) != 0 || base.ts < 0) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_TS, "wrong ts");
		return NULL;
	}
	str = mp_decode_str(&data, &len);
	base.type = STRN2ENUM(promote_msg_type, str, len);
	if (base.type == promote_msg_type_MAX) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_TYPE, "wrong type");
		return NULL;
	}

	switch(base.type) {
	case PROMOTE_MSG_BEGIN:
		base.begin.quorum = -1;
		base.begin.timeout = 0;
		if (opts_decode(&base, promote_msg_begin_format, &data,
				ER_WRONG_PROMOTION_RECORD,
				BOX_PROMOTION_FIELD_VALUE, region) != 0)
			return NULL;
		if (base.begin.quorum <= replicaset.applier.total / 2) {
			diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
				 BOX_PROMOTION_FIELD_VALUE, "quorum should be "\
				 "> 50%% of replicaset size");
			return NULL;
		}
		break;
	case PROMOTE_MSG_STATUS:
		base.status.is_master = false;
		if (opts_decode(&base, promote_msg_status_format, &data,
				ER_WRONG_PROMOTION_RECORD,
				BOX_PROMOTION_FIELD_VALUE, region) != 0)
			return NULL;
		break;
	case PROMOTE_MSG_ERROR:
		base.error.code = -1;
		base.error.message = NULL;
		if (opts_decode(&base, promote_msg_error_format, &data,
				ER_WRONG_PROMOTION_RECORD,
				BOX_PROMOTION_FIELD_VALUE, region) != 0)
			return NULL;
		if (base.error.code < 0 || base.error.message == NULL) {
			diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
				 BOX_PROMOTION_FIELD_VALUE, "error code and "\
				 "message should be specified");
			return NULL;
		}
		msg_sizeof += strlen(base.error.message) + 1;
		break;
	default:
		if (mp_typeof(*data) != MP_NIL) {
			diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
				 BOX_PROMOTION_FIELD_VALUE,
				 tt_sprintf("'%s' has to have value nil",
					    promote_msg_type_strs[base.type]));
			return NULL;
		}
		mp_decode_nil(&data);
		break;
	};
	struct promote_msg *msg = (struct promote_msg *) malloc(msg_sizeof);
	if (msg == NULL) {
		diag_set(OutOfMemory, msg_sizeof, "malloc", "msg");
		return NULL;
	}
	*msg = base;
	msg->base.destroy = (void(*)(struct ipc_msg *)) promote_msg_delete;
	if (msg->type == PROMOTE_MSG_ERROR) {
		char *errmsg = (char *) (msg + 1);
		memcpy(errmsg, base.error.message, msg_sizeof - sizeof(*msg));
		msg->error.message = errmsg;
	}
	return msg;
}

/** True, if @a msg is created by the current instance. */
static inline bool
promote_msg_is_mine(const struct promote_msg *msg)
{
	return tt_uuid_is_equal(&msg->source_uuid, &INSTANCE_UUID);
}

/**
 * Wrapper for promote_send_f to send the message in a separate
 * fiber. It is needed to be able to write records into _promotion
 * space from on_commit trigger where core promotion logic is
 * concentrated and a transaction exists already (though it is
 * committed).
 */
static inline int
promote_send(const struct promote_msg *msg)
{
	/*
	 * Do nothing on recovery. If a message was sent on the
	 * previous work session, it would be recovered among next
	 * rows.
	 */
	if (! box_is_configured())
		return 0;
	const char *data = promote_msg_encode(msg);
	if (data == NULL)
		return -1;
	return boxk(IPROTO_INSERT, BOX_PROMOTION_ID, "%p", data);
}

/**
 * Create the promotion message.
 * @param[out] msg Message to create.
 * @param type Type to set to @a msg.
 */
static inline void
promote_msg_create(struct promote_msg *msg, enum promote_msg_type type)
{
	msg->round_id = promote_state.round_id;
	msg->round_uuid = promote_state.round_uuid;
	msg->source_uuid = INSTANCE_UUID;
	msg->ts = fiber_time();
	msg->type = type;
	msg->step = ++promote_state.step;
}

/**
 * Send a 'begin' promotion message. For this a new round is
 * initialized and round_id is incremented.
 */
static inline int
promote_send_begin(int quorum, double timeout)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_BEGIN);
	tt_uuid_create(&msg.round_uuid);
	msg.begin.quorum = quorum;
	msg.begin.timeout = timeout;
	msg.round_id++;
	msg.step = 1;
	return promote_send(&msg);
}

/**
 * Send a 'status' promotion message. It contains a role of this
 * instance. The message is sent as a response to 'begin' message.
 */
static inline int
promote_send_status(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_STATUS);
	msg.status.is_master = ! box_is_ro();
	return promote_send(&msg);
}

/**
 * Send a 'sync' promotion message. It is sent by this instance if
 * it is an old master to be demoted. Sync brings this instance
 * into read-only mode, while watchers and the initiator responds
 * to this message with 'success'.
 */
static inline int
promote_send_sync(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_SYNC);
	return promote_send(&msg);
}

/**
 * Send a 'success' promotion message. It is sent by a promotion
 * watcher and an initiator as a response to 'sync' and by an old
 * master when the sync is successfull. The later means the whole
 * promotion round success.
 */
static inline int
promote_send_success(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_SUCCESS);
	return promote_send(&msg);
}

/**
 * Send an 'error' promotion message. It is sent by any instace
 * on different errors like timeout, multiple masters discovery,
 * local errors (OOM, WAL error etc). This message is sent in
 * scope of the current round and on commit terminates the local
 * promotion state.
 */
static inline int
promote_send_error(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_ERROR);
	struct error *e = box_error_last();
	msg.error.code = box_error_code(e);
	msg.error.message = box_error_message(e);
	return promote_send(&msg);
}

/**
 * Send an 'error' promotion message out of scope of the current
 * round. For example, as a response to unexpected message from
 * another round while there are the current round active.
 */
static inline int
promote_send_out_of_bound_error(int round_id, const struct tt_uuid *round_uuid,
				int step)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_ERROR);
	msg.round_id = round_id;
	msg.round_uuid = *round_uuid;
	struct error *e = box_error_last();
	msg.error.code = box_error_code(e);
	msg.error.message = box_error_message(e);
	msg.step = step;
	return promote_send(&msg);
}

int
box_check_ro_is_mutable()
{
	if (! promote_state.is_role_committed)
		return 0;
	diag_set(ClientError, ER_CFG, "read_only", "can not change the option "\
		 "when box.ctl.promote() was used");
	return -1;
}

int
box_ctl_promote(double timeout, int quorum)
{
	if (quorum < 0)
		quorum = replicaset.applier.total;
	if (! box_is_ro()) {
		diag_set(ClientError, ER_PROMOTE, "non-initialized",
			 "the initiator is already master");
		return -1;
	}
	if (promote_is_active()) {
		diag_set(ClientError, ER_PROMOTE_EXISTS);
		return -1;
	}
	if (quorum <= replicaset.applier.total / 2) {
		diag_set(ClientError, ER_PROMOTE, "non-initialized",
			 tt_sprintf("too small quorum, expected > %d, "\
				    "but got %d", replicaset.applier.total / 2,
				    quorum));
		return -1;
	}
	int id = promote_state.round_id;
	if (promote_send_begin(quorum, timeout) != 0)
		return -1;

	while (promote_state.round_id == id ||
	       promote_state.phase != PROMOTE_PHASE_SUCCESS) {
		fiber_cond_wait(&promote_state.on_change);
		if (promote_state.phase == PROMOTE_PHASE_ERROR) {
			assert(! diag_is_empty(&promote_state.diag));
			diag_move(&promote_state.diag, diag_get());
			return -1;
		}
	}
	return 0;
}

/**
 * Delete the promotion round with the specified id.
 * @param id Round ID to delete by.
 * @param[out] next_id ID of a next round.
 * @param pk Primary index of the _promotion space.
 *
 * @retval 0 Success.
 * @retval -1 Error.
 */
static inline int
promote_clean_round(uint32_t id, uint32_t *next_id, struct index *pk)
{
	if (promote_is_active()) {
		diag_set(ClientError, ER_PROMOTE_EXISTS);
		return -1;
	}
	char key[16];
	mp_encode_uint(key, id);
	if (index_count(pk, ITER_ALL, NULL, 0) == 0)
		return 0;
	struct request request;
	memset(&request, 0, sizeof(request));
	request.type = IPROTO_DELETE;
	request.space_id = BOX_PROMOTION_ID;
	struct iterator *it = index_create_iterator(pk, ITER_GE, key, 1);
	if (it == NULL)
		return -1;
	if (box_txn_begin() != 0) {
		iterator_delete(it);
		return -1;
	}
	struct tuple *t;
	int rc;
	const struct key_def *pk_def = pk->def->key_def;
	while ((rc = iterator_next(it, &t)) == 0 && t != NULL) {
		tuple_field_u32(t, BOX_PROMOTION_FIELD_ID, next_id);
		if (*next_id != id)
			break;
		const char *del = tuple_extract_key(t, pk_def, NULL);
		if (del == NULL)
			goto rollback;
		if (boxk(IPROTO_DELETE, BOX_PROMOTION_ID, "%p", del) != 0)
			goto rollback;
	}
	if (rc != 0 || box_txn_commit() != 0)
		goto rollback;
	iterator_delete(it);
	return 0;
rollback:
	box_txn_rollback();
	iterator_delete(it);
	return -1;
}

int
promote_reset_until(uint32_t until)
{
	uint32_t id, next_id = 0;
	struct index *pk = space_index(space_by_id(BOX_PROMOTION_ID), 0);
	do {
		id = next_id;
		if (promote_clean_round(id, &next_id, pk) != 0)
			return -1;
	} while (id != next_id && next_id < until);
	return 0;
}

int
box_ctl_promote_reset(void)
{
	if (promote_reset_until(UINT32_MAX) != 0)
		return -1;
	promote_state.phase = PROMOTE_PHASE_INACTIVE;
	promote_state.is_role_committed = false;
	return 0;
}

void
box_ctl_promote_info(struct info_handler *info)
{
	struct promote_state *s = &promote_state;
	info_begin(info);
	if (s->phase == PROMOTE_PHASE_INACTIVE) {
		info_end(info);
		return;
	}
	info_append_int(info, "round_id", s->round_id);
	info_append_str(info, "round_uuid", tt_uuid_str(&s->round_uuid));
	if (promote_is_initiator_known()) {
		info_append_str(info, "initiator_uuid",
				tt_uuid_str(&s->initiator_uuid));
		info_append_int(info, "quorum", s->quorum);
		info_append_double(info, "timeout", s->timeout);
	}
	info_append_str(info, "role", promote_role_strs[s->role]);
	info_append_str(info, "phase", promote_phase_strs[s->phase]);
	info_append_str(info, "comment", s->comment);
	if (promote_is_master_known()) {
		info_append_str(info, "master_uuid",
				tt_uuid_str(&s->master_uuid));
	}
	info_end(info);
}

void
promote_msg_push(struct promote_msg *msg)
{
	fiber_channel_put_msg_timeout(promote_state.channel, &msg->base,
				      TIMEOUT_INFINITY);
}

/** Set a new role, update virtual table, expose read_only. */
static void
promote_state_set_role(enum promote_role role);

/** Placeholder to skip some messages when they do not matter. */
static void
promote_msg_skip(const struct promote_msg *msg)
{
	(void) msg;
}

/**
 * A function to assure the message can not reach a state of the
 * promotion.
 */
static void
promote_msg_unreachable(const struct promote_msg *msg)
{
	(void) msg;
	unreachable();
}

/** Undefined role. {{{ */

static void
promote_default_begin(const struct promote_msg *msg)
{
	assert(msg->type == PROMOTE_MSG_BEGIN);
	promote_state.initiator_uuid = msg->source_uuid;
	promote_state.quorum = msg->begin.quorum;
	promote_state.timeout = msg->begin.timeout;
	evio_timeout_init(loop(), &promote_state.round_start,
			  &promote_state.round_delay, promote_state.timeout);
	if (! promote_msg_is_mine(msg))
		promote_send_status();
	else
		promote_state_set_role(PROMOTE_ROLE_INITIATOR);
}

static void
promote_default_new_replica(const struct promote_msg *msg)
{
	assert(msg->type == PROMOTE_MSG_STATUS);
	assert(! msg->status.is_master);
	if (promote_msg_is_mine(msg))
		promote_state_set_role(PROMOTE_ROLE_WATCHER);
	++promote_state.watcher_count;
}

static void
promote_default_new_master(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_UNDEFINED);
	assert(msg->type == PROMOTE_MSG_STATUS);
	assert(msg->status.is_master);
	if (promote_msg_is_mine(msg)) {
		promote_state_set_role(PROMOTE_ROLE_MASTER);
		/* Synced with self. */
		promote_state.sync_count++;
		promote_send_sync();
	}
}

static void
promote_default_sync(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_UNDEFINED);
	assert(msg->type == PROMOTE_MSG_SYNC);
	assert(! promote_msg_is_mine(msg));
	promote_state_set_role(PROMOTE_ROLE_WATCHER);
	promote_comment("promotion is started, 'sync' is received before my "\
			"status was committed so I am not a master and not an "\
			"initiator, but watcher");
	promote_send_success();
}

static void
promote_default_error(const struct promote_msg *msg)
{
	assert(msg->type == PROMOTE_MSG_ERROR);
	promote_comment("the round failed due to the error: %s",
			msg->error.message);
	promote_state.phase = PROMOTE_PHASE_ERROR;
	box_error_raise(msg->error.code, "%s", msg->error.message);
	diag_move(diag_get(), &promote_state.diag);
}

static struct promote_state_vtab default_vtab = {
	/* .begin = */ promote_default_begin,
	/* .new_replica = */ promote_default_new_replica,
	/* .new_master = */ promote_default_new_master,
	/* .sync = */ promote_default_sync,
	/* .success = */ promote_msg_skip,
	/* .error = */ promote_default_error,
};

/** Undefined role. }}} */

/** Initiator role. {{{ */

static void
promote_initiator_new_replica(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_INITIATOR);
	assert(msg->type == PROMOTE_MSG_STATUS);
	assert(! msg->status.is_master);
	++promote_state.watcher_count;
	if (! promote_is_cluster_readonly())
		return;
	/*
	 * The cluster is readonly and 100% available. Then the
	 * promotion is safe allowed. But the initiator plays for
	 * an old master.
	 */
	promote_comment("the cluster is completely readonly, the initiator "\
			"acts on behalf of an old master ");
	/* Synced with self. */
	promote_state.sync_count++;
	promote_send_sync();
}

static void
promote_initiator_sync(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_INITIATOR);
	assert(msg->type == PROMOTE_MSG_SYNC);
	if (promote_msg_is_mine(msg))
		assert(promote_is_cluster_readonly());
	else
		promote_send_success();
}

static void
promote_initiator_success(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_INITIATOR);
	assert(msg->type == PROMOTE_MSG_SUCCESS);
	/*
	 * The round is finished successfully in two cases: the
	 * old master've sent 'success' or the cluster is
	 * read-only and each replica've sent 'success'.
	 */
	if (tt_uuid_is_equal(&msg->source_uuid, &promote_state.master_uuid) ||
	    (promote_is_cluster_readonly() &&
	     ++promote_state.sync_count == promote_state.quorum)) {
		promote_comment("the new master is promoted");
		promote_state.phase = PROMOTE_PHASE_SUCCESS;
		box_set_ro(false);
		box_expose_ro();
		promote_reset_until(promote_state.round_id);
	}
}

static struct promote_state_vtab initiator_vtab = {
	/* .begin = */ promote_msg_unreachable,
	/* .new_replica = */ promote_initiator_new_replica,
	/* .new_master = */ promote_msg_skip,
	/* .sync = */ promote_initiator_sync,
	/* .success = */ promote_initiator_success,
	/* .error = */ promote_default_error,
};

/** Initiator role. }}} */

/** Master role. {{{ */

static void
promote_master_sync(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_MASTER);
	assert(msg->type == PROMOTE_MSG_SYNC);
	/*
	 * A foreign sync can be received here if before a second
	 * master was revealed via its status message, but an
	 * error, sent in response to the latter, did not manage
	 * to commit.
	 */
	if (! promote_msg_is_mine(msg))
		return;
	promote_comment("old master entered readonly "\
			"mode to sync with slaves");
	box_set_ro(true);
	box_expose_ro();
}

static void
promote_master_success(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_MASTER);
	assert(msg->type == PROMOTE_MSG_SUCCESS);
	/*
	 * The master sends 'success' to notify the initiator
	 * about the round successfull finish.
	 */
	if (promote_msg_is_mine(msg)) {
		promote_state.phase = PROMOTE_PHASE_SUCCESS;
		promote_comment("the old master is demoted completely");
	} else if (++promote_state.sync_count == promote_state.quorum) {
		promote_send_success();
	}
}

static void
promote_master_error(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_MASTER);
	assert(msg->type == PROMOTE_MSG_ERROR);
	if (promote_state.phase == PROMOTE_PHASE_IN_PROGRESS && box_is_ro()) {
		promote_comment("the old master is back in read-write mode "\
				"due to the error");
		box_set_ro(false);
		box_expose_ro();
	}
	promote_default_error(msg);
}

static struct promote_state_vtab master_vtab = {
	/* .begin = */ promote_msg_unreachable,
	/* .new_replica = */ promote_default_new_replica,
	/* .new_master = */ promote_msg_unreachable,
	/* .sync = */ promote_master_sync,
	/* .success = */ promote_master_success,
	/* .error = */ promote_master_error,
};

/** Master role. }}} */

/** Watcher role. {{{ */

static void
promote_watcher_sync(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_WATCHER);
	assert(msg->type == PROMOTE_MSG_SYNC);
	promote_send_success();
}

static void
promote_watcher_success(const struct promote_msg *msg)
{
	assert(promote_state.role == PROMOTE_ROLE_WATCHER);
	assert(msg->type == PROMOTE_MSG_SUCCESS);
	if (promote_msg_is_mine(msg)) {
		promote_state.phase = PROMOTE_PHASE_SUCCESS;
		promote_comment("the watcher has voted and left the round");
	}
}

static struct promote_state_vtab watcher_vtab = {
	/* .begin = */ promote_default_begin,
	/* .new_replica = */ promote_default_new_replica,
	/* .new_master = */ promote_msg_skip,
	/* .sync = */ promote_watcher_sync,
	/* .success = */ promote_watcher_success,
	/* .error = */ promote_default_error,
};

/** Watcher role. }}} */

static void
promote_state_set_role(enum promote_role role)
{
	promote_state.role = role;
	switch(role) {
	case PROMOTE_ROLE_UNDEFINED:
		promote_state.vtab = &default_vtab;
		return;
	case PROMOTE_ROLE_INITIATOR:
		promote_state.vtab = &initiator_vtab;
		box_set_ro(true);
		break;
	case PROMOTE_ROLE_MASTER:
		promote_state.vtab = &master_vtab;
		box_set_ro(false);
		break;
	case PROMOTE_ROLE_WATCHER:
		promote_state.vtab = &watcher_vtab;
		box_set_ro(true);
		break;
	}
	promote_state.is_role_committed = true;
	box_expose_ro();
	promote_comment("promotion is started, my promotion role is %s",
			 promote_role_strs[role]);
}

/**
 * Check a new message belongs to the current round, or start a
 * new one. Forward it to the appropriate virtual method.
 */
static void
promote_msg_process(const struct promote_msg *msg)
{
	if (box_is_configured()) {
		say_info("promotion message has %s: %s",
			 promote_msg_is_mine(msg) ? "commited" : "received",
			 promote_msg_str(msg));
	} else {
		say_info("promotion message has recovered: %s",
			 promote_msg_str(msg));
	}
	if (! promote_is_active()) {
		if (msg->round_id <= promote_state.round_id) {
			say_info("Ignored outdated round id %u, expected > %u",
				 msg->round_id, promote_state.round_id);
			return;
		}
		promote_state.step = 1;
		promote_state.round_id = msg->round_id;
		promote_state.round_uuid = msg->round_uuid;
		promote_state.master_uuid = uuid_nil;
		promote_state.initiator_uuid = uuid_nil;
		diag_clear(&promote_state.diag);
		promote_state.phase = PROMOTE_PHASE_IN_PROGRESS;
		promote_state.sync_count = 0;
		promote_state.watcher_count = 0;
		/*
		 * Begin and quorum can not be set right now,
		 * because the first message may be non-begin and
		 * thus does not contain any round initial info.
		 * It is called message reordeing and it possible
		 * when, for example, one instance downloads the
		 * same round messages from two different
		 * instances. Some of them can be received
		 * earlier, but commited later breaking the order.
		 * So it is not allowed to trust the order.
		 *
		 * As long as 'status' message is not commited
		 * yet, the role is undefined as well. It is not
		 * possible to use box_is_ro() right here since it
		 * can be recovery. And by recovery of its own
		 * 'status' messages the instance restores its
		 * read_only flag and the role.
		 */
		promote_state_set_role(PROMOTE_ROLE_UNDEFINED);
	} else if (! promote_is_this_round_msg(msg)) {
		/*
		 * Do not respond error on error, or else an
		 * infinite error messages exchange will be
		 * started.
		 */
		if (msg->type == PROMOTE_MSG_ERROR)
			return;
		diag_set(ClientError, ER_PROMOTE, tt_uuid_str(&msg->round_uuid),
			 "unexpected message");
		promote_send_out_of_bound_error(msg->round_id, &msg->round_uuid,
						msg->step + 1);
		return;
	} else {
		promote_state.step = MAX(msg->step, promote_state.step);
	}
	/*
	 * The main processing switch. Here each instance of each
	 * type responds to each type of message.
	 */
	switch (msg->type) {
	case PROMOTE_MSG_BEGIN:
		promote_state.vtab->begin(msg);
		break;
	case PROMOTE_MSG_STATUS:
		if (! msg->status.is_master) {
			promote_state.vtab->new_replica(msg);
			break;
		}
		if (! promote_is_master_known()) {
			promote_state.master_uuid = msg->source_uuid;
			promote_state.vtab->new_master(msg);
			break;
		}
		diag_set(ClientError, ER_PROMOTE,
			 tt_uuid_str(&promote_state.round_uuid),
			 tt_sprintf("two masters exist: '%s' and '%s'",
				    tt_uuid_str(&msg->source_uuid),
				    tt_uuid_str(&promote_state.master_uuid)));
		promote_send_error();
		break;
	case PROMOTE_MSG_SYNC:
		promote_state.vtab->sync(msg);
		break;
	case PROMOTE_MSG_SUCCESS:
		promote_state.vtab->success(msg);
		break;
	case PROMOTE_MSG_ERROR:
		promote_state.vtab->error(msg);
		break;
	default:
		unreachable();
		break;
	}
	promote_state.round_id = MAX(promote_state.round_id, msg->round_id);
	fiber_cond_broadcast(&promote_state.on_change);
}

/**
 * Background worker processing promotion messages, handling
 * timeouts.
 */
static int
promote_worker_f(va_list ap)
{
	(void) ap;
	fiber_set_cancellable(true);
	ev_tstamp *start = &promote_state.round_start;
	ev_tstamp *delay = &promote_state.round_delay;
	evio_timeout_init(loop(), start, delay, TIMEOUT_INFINITY);
	struct promote_msg *msg;
	while (true) {
		int rc = fiber_channel_get_msg_timeout(promote_state.channel,
						       (struct ipc_msg **) &msg,
						       *delay);
		evio_timeout_update(loop(), *start, delay);
		if (rc == 0) {
			promote_msg_process(msg);
			promote_msg_delete(msg);
			continue;
		}
		if (fiber_is_cancelled()) {
			fiber_channel_delete(promote_state.channel);
			fiber_cond_destroy(&promote_state.on_change);
			return 0;
		}
		if (promote_is_active()) {
			promote_state.step++;
			promote_send_error();
		}
		evio_timeout_init(loop(), start, delay, TIMEOUT_INFINITY);
	}
}

int
box_ctl_promote_init(void)
{
	memset(&promote_state, 0, sizeof(promote_state));
	fiber_cond_create(&promote_state.on_change);
	promote_state.channel = fiber_channel_new(100);
	promote_state.worker = fiber_new("promote worker", promote_worker_f);
	if (promote_state.worker == NULL)
		panic("Can not start a promotion worker");
	promote_state_set_role(PROMOTE_ROLE_UNDEFINED);
	fiber_start(promote_state.worker);
	return 0;
}

void
box_ctl_promote_free(void)
{
	fiber_cancel(promote_state.worker);
}
